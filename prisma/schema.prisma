// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  binaryTargets   = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [citext]
}

enum Theme {
  lofi_girl
  matcha_latte
  sky_blue
  night_mode
  strawberry
}

enum RoomStatus {
  idle
  running
  paused
  ended
}

enum Role {
  host
  guest
}

enum SegmentKind {
  focus
  break
  long_break
  custom
}

enum Visibility {
  private
  public
}

enum ProposalType {
  add_segment
  edit_segment
  public_task
}

enum ProposalStatus {
  pending
  accepted
  rejected
}

model Room {
  id                  String       @id @default(uuid())
  code                String       @unique
  hostSessionId       String       @map("host_session_id")
  hostUserId          String?      @map("host_user_id")
  theme               Theme        @default(lofi_girl)
  status              RoomStatus   @default(idle)
  currentSegmentIndex Int          @default(0) @map("current_segment_index")
  startsAt            DateTime?    @map("starts_at")
  createdAt           DateTime     @default(now()) @map("created_at")
  expiresAt           DateTime     @map("expires_at")
  
  segments            Segment[]
  participants        Participant[]
  tasks               Task[]
  proposals           Proposal[]
  messages            Message[]

  @@map("rooms")
}

model Segment {
  id          String      @id @default(uuid())
  roomId      String      @map("room_id")
  kind        SegmentKind
  label       String
  durationSec Int         @map("duration_sec")
  order       Int
  publicTask  String?     @map("public_task")

  room        Room        @relation(fields: [roomId], references: [id], onDelete: Cascade)
  tasks       Task[]

  @@index([roomId, order])
  @@map("segments")
}

model Participant {
  id          String    @id @default(uuid())
  roomId      String    @map("room_id")
  sessionId   String    @map("session_id")
  userId      String?   @map("user_id")
  displayName String    @map("display_name")
  role        Role      @default(guest)
  isMuted     Boolean   @default(false) @map("is_muted")
  joinedAt    DateTime  @default(now()) @map("joined_at")
  lastSeenAt  DateTime  @default(now()) @map("last_seen_at")

  room        Room      @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user        User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  tasks       Task[]
  proposals   Proposal[]
  messages    Message[]
  messageReactions MessageReaction[]

  @@unique([roomId, sessionId])
  @@unique([roomId, userId])
  @@index([roomId, sessionId])
  @@index([userId])
  @@map("participants")
}

model Task {
  id            String     @id @default(uuid())
  roomId        String     @map("room_id")
  segmentId     String     @map("segment_id")
  participantId String     @map("participant_id")
  visibility    Visibility @default(private)
  text          String
  createdAt     DateTime   @default(now()) @map("created_at")
  updatedAt     DateTime   @updatedAt @map("updated_at")

  room          Room       @relation(fields: [roomId], references: [id], onDelete: Cascade)
  segment       Segment    @relation(fields: [segmentId], references: [id], onDelete: Cascade)
  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)

  @@unique([segmentId, participantId])
  @@map("tasks")
}

model Proposal {
  id           String         @id @default(uuid())
  roomId       String         @map("room_id")
  type         ProposalType
  payload      Json
  status       ProposalStatus @default(pending)
  createdBy    String         @map("created_by")
  createdAt    DateTime       @default(now()) @map("created_at")
  moderatedAt  DateTime?      @map("moderated_at")

  room         Room           @relation(fields: [roomId], references: [id], onDelete: Cascade)
  participant  Participant    @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([roomId, status])
  @@map("proposals")
}

model Message {
  id             String      @id @default(uuid())
  roomId         String      @map("room_id")
  participantId  String      @map("participant_id")
  text           String
  reactions      Json        @default("{}") // legacy - stop using in code
  isShadowHidden Boolean     @default(false) @map("is_shadow_hidden")
  createdAt      DateTime    @default(now()) @map("created_at")

  // ✅ Replies (self relation)
  replyToId      String?     @map("reply_to_id")
  replyTo        Message?    @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies        Message[]   @relation("MessageReplies")

  // ✅ Reactions table
  reactionRows   MessageReaction[]

  room           Room        @relation(fields: [roomId], references: [id], onDelete: Cascade)
  participant    Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)

  @@index([roomId, createdAt])
  @@index([replyToId])
  @@map("messages")
}

model MessageReaction {
  id            String      @id @default(uuid())
  messageId     String      @map("message_id")
  participantId String      @map("participant_id")
  emoji         String      @db.VarChar(24)
  createdAt     DateTime    @default(now()) @map("created_at")

  message       Message     @relation(fields: [messageId], references: [id], onDelete: Cascade)
  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)

  // one participant can react once per emoji per message (toggle)
  @@unique([messageId, participantId, emoji])
  @@index([messageId])
  @@map("message_reactions")
}

model DailyStatistic {
  id                      String   @id @default(uuid())
  date                    DateTime @unique @db.Date
  roomsCreated            Int      @default(0) @map("rooms_created")
  totalParticipants       Int      @default(0) @map("total_participants")
  totalSessions           Int      @default(0) @map("total_sessions")
  totalFocusMinutes       Int      @default(0) @map("total_focus_minutes")
  updatedAt               DateTime @updatedAt @map("updated_at")

  @@map("daily_statistics")
}

model Report {
  id        String   @id @default(uuid())
  name      String?
  subject   String
  message   String
  createdAt DateTime @default(now()) @map("created_at")

  @@map("reports")
}

// --- NextAuth Models ---

model Account {
  id                 String  @id @default(cuid())
  userId             String  @map("user_id")
  type               String
  provider           String
  providerAccountId  String  @map("provider_account_id")
  refresh_token      String? @db.Text
  access_token       String? @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String? @db.Text
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("sessions")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime? @map("email_verified")
  image         String?
  passwordHash  String?   @map("password_hash") // Added for Credentials Provider
  accounts      Account[]
  sessions      Session[]
  participants  Participant[]
  profile       UserProfile?

  @@map("users")
}

model UserProfile {
  id               String   @id @default(uuid())
  userId           String   @unique @map("user_id")

  displayName      String   @map("display_name")
  avatarUrl        String?  @map("avatar_url")
  bio              String?  @db.VarChar(280) // Twitter-style length

  // Identity
  username         String?  @unique @db.Citext
  usernameSetAt    DateTime? @map("username_set_at")

  profileCompleted Boolean  @default(false) @map("profile_completed")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([username])
  @@index([displayName])
  @@map("user_profiles")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}
